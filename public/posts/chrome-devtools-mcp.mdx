---
slug: chrome-devtools-mcp
title: "Chrome DevTools MCP"
description: "이제 브라우저에서 디버깅도 AI가?"
tags: ["ai"]
createdAt: "2025.10.17"
---

회사에서 **Claude Code**를 도입하며, "AI 도구를 실무에 어떻게 활용하여 어떤 것들을 개선하면 좋을까?"를 팀원들과 함께 실험 중입니다.
몇몇 분들은 **Figma MCP**를 통해 간단한 템플릿 컴포넌트/페이지를 자동 생성하는 에이전트 및 커맨드를 생성해 보시기도 했습니다.
반복적인 마크업을 빠르게 쌓을 수 있다는 점이 꽤 유용했죠.

그러던 중, 제가 우연히 [GeekNews](https://news.hada.io/topic?id=23284)에서 **Chrome DevTools MCP**가 공개되었다는 아티클을 발견하게 되었습니다.
그리고 여기서 생각이 이어졌습니다.

> "Figma MCP가 만든 컴포넌트나 페이지를 Chrome DevTools MCP를 통해 1차적으로 검증하면 어떨까?"

즉, 해당 MCP를 통해 **AI가 만든 결과물을 실제 브라우저에서 띄워보고, 렌더링/성능/접근성을 1차로 점검**하는 루프를 만들고자 했습니다.


## MCP란? 🤔

> **Model Context Protocol**

저는 Chrome DevTools MCP를 사용해보기 전, 우선 `MCP`라는 용어에 대해 먼저 이해하고 넘어가려고 했습니다.

`MCP`는 Anthropic이 제안한 `오픈소스 표준 프로토콜`로,
**AI 애플리케이션을 외부 시스템에 연결**할 수 있게 해주는 프로토콜입니다.

쉽게 말하자면, USB-C처럼 **다양한 기기를 하나의 표준으로 연결**하듯이,
MCP는 AI와 데이터 소스, 도구, 워크플로우를 표준화된 방식으로 연결합니다.

기존의 AI는 "텍스트 입력 → 텍스트 출력"이라는 고립된 환경에 제한되어 있었지만,
MCP를 통해 **AI가 특정 데이터나 도구에 접근**할 수 있게 되었습니다.

예를 들어, Claude는 MCP를 통해 다음과 같은 일을 할 수 있습니다.

- Figma MCP → 디자인 파일 제어, 컴포넌트 자동 생성
- Chrome DevTools MCP → 브라우저 실행 및 성능 측정
- GitHub MCP → 저장소 관리, PR 생성 및 리뷰


## Chrome DevTools MCP

**Chrome DevTools MCP**는 AI 에이전트(Claude, Cursor, Gemini 등)가 **Chrome 브라우저를 조작**할 수 있게 도와주는 MCP 서버입니다.

간단히 말하면, **AI와 Chrome DevTools 사이의 다리 역할**을 합니다.  
사용자가 자연어로 요청하면, AI가 이를 분석하여 적절한 MCP 툴을 선택하고, MCP 서버가 Chrome을 제어한 뒤 결과를 반환합니다.

예를 들어 "이 웹사이트 성능 체크해줘"라고 요청하면, AI가 자동으로 성능 측정 툴을 호출하여 분석 결과를 제공합니다.

내부적으로는 Node.js 기반으로 동작하며, AI와는 `JSON-RPC` 형식의 **stdio(표준 입출력)**로 통신하고, `Puppeteer`를 통해 **CDP(Chrome DevTools Protocol)**에 접근합니다.
제공하는 26개의 툴 목록과 상세 기능은 [Chrome DevTools MCP Tool Reference](https://github.com/ChromeDevTools/chrome-devtools-mcp/blob/main/docs/tool-reference.md)에서 확인할 수 있습니다.

### 플로우

그럼 좀더 자세한 흐름에 대해 알아봅시다.
특정 페이지의 성능을 측정해야한다고 가정해볼까요?
그리고 해당 작업을 Claude Code에 Chrome DevTools MCP를 연결하여 수행한다면 다음과 같은 플로우로 진행됩니다.

#### 1. 사용자 입력
```javascript
> "https://example.com"의 성능을 체크해줘
```

#### 2. Claude Code (AI 분석)
Claude Code는 사용자가 입력한 자연어를 분석하고 문맥을 파악하기 시작합니다.
그리고 어떤 작업이 필요한지 결정하게 됩니다.

위 예시를 바탕으로, 현재는 `성능 측정`이 필요하다고 결정하고
Chrome DevTools MCP의 tool 중 이를 위해 필요한 아래와 같은 tool들을 선택합니다.

```text
 navigate_page → performance_start_trace → performance_stop_trace
```
   
#### 3. Claude Code → MCP 서버 (stdin)
이제 MCP 서버와 통신을 시작하는데, 먼저 브라우저가 실행되고 있는지 확인을 진행합니다.
만약 실행되고 있지 않다면, 디버깅용 브라우저를 실행합니다.

그리고 이어서 선택한 tool들을 차례대로 실행하며 브라우저를 제어하기 시작합니다.

```json
/* 0. 브라우저 실행 */
  {
    "method": "tools/call", 
    "params": {
      "name": "new_page",
      "arguments": {
        "url": "about:blank"
      }
    }
  }

/* 1. 페이지 이동 */
  {
    "method": "tools/call", 
    "params": {
      "name": "navigate_page",
      "arguments": {
        "url": "https://example.com"
      }
    }
  }

/* 2. 성능 측정 시작 */
  {
    "method": "tools/call", 
    "params": {
      "name": "performance_start_trace",
      "arguments": {}
    }
  }

/* 3. 성능 측정 종료 */
  {
    "method": "tools/call", 
    "params": {
      "name": "performance_stop_trace",
      "arguments": {}
    }
  }
```


#### 4. MCP 서버 (registerTool 핸들러)
- tool.handler() 실행 ([src/tools/performance.ts](https://github.com/ChromeDevTools/chrome-devtools-mcp/blob/main/src/tools/performance.ts))
- Chrome DevTools로 성능 트레이스 분석
- LCP, FCP 등 메트릭 추출

#### 5. McpResponse.handle()
MCP 서버에서 추출한 성능 데이터를 이제 `"LCP: 2.5s, FCP: 1.2s..."` 형식과 같이 포맷팅하여 Claude Code에 전달할 준비를 시작합니다.

#### 6. MCP 서버 → Claude Code (stdout)
MCP는 아래와 같이 포맷팅한 데이터를 Claude Code에게 전달합니다.

```json
  {
    "result": {
      "content": [
        {
          "type": "text",
          "text": "# performance_stop_trace response\nLCP: 2.5s\n..."
        }
      ]
    }
  }
```

#### 7. Claude Code (AI 해석)
Claude Code는 받은 성능 메트릭을 분석하여 "LCP 2.5s는 개선이 필요하다"고 판단하고, 이를 바탕으로 최적화 제안을 생성합니다.

#### 8. 사용자에게 응답
```text
  "example.com의 성능을 분석했습니다.
  - LCP: 2.5초 (권장: 2.5초 이하)
  - 큰 이미지 로드가 지연 원인입니다
  - 이미지 압축과 lazy loading을 추천합니다"
```